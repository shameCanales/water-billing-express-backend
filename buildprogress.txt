
Entity Relationships:::::::::::::
Processor : 
  - Can create, update, and manage consumers, connections, and billing.
  - Can view and respond to issue reports.
  - Has a role (staff, manager).

Consumer : 
  - Can view their own profile, connections, bills, and issue reports.
  - Can create new issue reports (e.g., malfunctioning meter, leaking pipe)
  - Cannot modify billing or connection data.
  Relationships:
    - Consumer 1 - n connections
    - 1 Consumer - n issueReports

Connection:
  - Represents a water meter connection linked to a consumer
  - Each connection belongs to one consumer.
  - Each connection can have multiple billing records (monthly, quarterly, etc.)
  - Can be linked  to IssureReports if the issue is about a specific connection.
  Relationship: 
    - Connection n - 1 Consumer
    - Connection 1 - n billing

Billing:
  - Represents a single billing record for a connection (e,g. per month).
  - Belongs to exactly one connection.
  - Contains usage, rates total, payment status, etc.
  Relationships:
    - Billing n - 1 Connection

IssueReport: 
  - Create be a consumer.
  - Can optionally link to a connection (if the issue relates to it)
  - Managed by processor users who can update the status:
  - Pending | taking action | resolved

ENTITY RELATIONSHIP DIAGRAM :::::::::::::::::
Processor (role=staff|manager)
     │
     │ manages
     ▼
Consumer (1) ────< (n) Connection (1) ────< (n) Billing
     │
     │ reports
     ▼
IssueReport (status=pending|taking_action|resolved)
     │
     └── optional → Connection


- processor => manages => Consumer
- Consumer(1) => (many) connections
- Connection (1) => (many) Billings

ARCHITECTURE:
- this is a modern, scalable architecture, just like professional SaaS and municipal systems use today.
- we'll use MVC + Services + repository pattern, with a clean separation of concerns, modern ES Modules, and async/await across the stack.

PLANNED ARCHITECTURE:
water-billing-backend/
├── src/
│   ├── app.js
│   ├── server.js
│   ├── config/
│   │   └── db.js
│   ├── modules/
│   │   ├── auth/
│   │   │   ├── auth.controller.js
│   │   │   ├── auth.routes.js
│   │   │   ├── auth.service.js
│   │   │   ├── auth.repository.js
│   │   │   └── auth.validation.js
│   │   ├── users/        # Consumers + Processors
│   │   │   ├── user.model.js
│   │   │   ├── user.controller.js
│   │   │   ├── user.routes.js
│   │   │   ├── user.service.js
│   │   │   └── user.repository.js
│   │   ├── connections/
│   │   │   ├── connection.model.js
│   │   │   ├── connection.controller.js
│   │   │   ├── connection.routes.js
│   │   │   ├── connection.service.js
│   │   │   └── connection.repository.js
│   │   ├── billing/
│   │   │   ├── billing.model.js
│   │   │   ├── billing.controller.js
│   │   │   ├── billing.routes.js
│   │   │   ├── billing.service.js
│   │   │   └── billing.repository.js
│   │   └── reports/
│   │       ├── report.model.js
│   │       ├── report.controller.js
│   │       ├── report.routes.js
│   │       ├── report.service.js
│   │       └── report.repository.js
│   ├── middleware/
│   │   ├── auth.middleware.js
│   │   ├── role.middleware.js        # restrict access by role
│   │   ├── error.middleware.js
│   │   └── validate.middleware.js
│   ├── utils/
│   │   ├── ApiResponse.js
│   │   ├── generateToken.js
│   │   └── roles.js                  # define USER_ROLES constants
│   ├── core/
│   │   ├── logger.js
│   │   └── AppError.js
├── .env
├── package.json
└── README.md

KEY CONCEPTS::::::::::: 
Controller - Handles HTTP request/responses. Calls Service layer
Service - Contains business logic (calculations, validation)
Repository - Handles Database operations using Mongoose
Model - Define data schema
middleware - Reusable logic (auth, validation, error handling).
Utils - Small helpers (JWT, formatters, response.)

example code for Access control logic.
Use a Role middleware (role.middleware.js) to protect routes:

export const authorizeRoles = (...roles) => {
  return (req, res, next) => {
    if (!roles.includes(req.user.role)) {
      return res.status(403).json({ message: "Access Denied" });
    }
    next();
  };
};

Example usage:
// Only processors can create billing
router.post(
  "/",
  authMiddleware,
  authorizeRoles("processor", "manager"),
  billingController.createBilling
);

// Consumers can view their own billing
router.get(
  "/my-bills",
  authMiddleware,
  authorizeRoles("consumer"),
  billingController.getMyBills
);

Recommended Tech stack
Layer                    Technology
Runtime                   Node.js
Framework                 Express.js
Database                  MongoDB + Mongoose
Auth                      Jsession + cookie =>
validation                express-validator
Password hashing          bcrypt
Logging                   x => Winston or pino
Env Mgmt                  dotenv
Error handling            Centralized custom AppError
Dev Tools                 Nodemon, ESLint, Prettier
Testing                   Jest/Supertest





:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
ARCHITECTURE IMPLEMENTATION:::::::::::::::::::::::::::::::::::


Architecture V1: "flat MVC style"
WATER_BILLING_SYSTEM/
│
├── coverage/
├── node_modules/
│
├── src/
│   ├── config/
│   │   └── settings.js
│   │
│   ├── controllers/
│   │   └── consumer.controller.js
│   │
│   ├── e2e/
│   │   └── index.test.js
│   │
│   ├── middlewares/
│   │   ├── authentication/
│   │   │   ├── requireAuth.js
│   │   │   └── requireAuthAndManager.js
│   │   │
│   │   ├── validationSchemas/
│   │   │   ├── addBillValidation.js
│   │   │   ├── addConnectionValidation.js
│   │   │   ├── addConsumerValidation.js
│   │   │   ├── editBillValidation.js
│   │   │   ├── editConnectionValidation.js
│   │   │   └── registerProcessorValidation.js
│   │   │
│   │   ├── authmiddleware.js
│   │   └── validateObjectId.js
│   │
│   ├── mongoose/
│   │   └── schemas/
│   │       ├── bill.js
│   │       ├── connection.js
│   │       ├── consumer.js
│   │       └── processor.js
│   │
│   ├── routes/
│   │   ├── auth.js
│   │   ├── bills.js
│   │   ├── connections.js
│   │   ├── consumers.js
│   │   ├── index.js
│   │   ├── issueReports.js
│   │   └── processors.js
│   │
│   ├── strategies/
│   │   └── local-strategy.js
│   │
│   ├── tests/
│   │   └── consumer.test.js
│   │
│   ├── utils/
│   │   ├── constants.js
│   │   └── helpers.js
│   │
│   ├── app.js
│   └── createApp.js
│
├── .babelrc
├── .env
├── buildprogress.txt
├── jest.config.mjs
├── jsconfig.json
├── package-lock.json
├── package.json


Architecture V2: Multilayer architecture

Multi-Layer Architecture in Express.js

1. What is Multi-Layer Architecture?
- Software design pattern that separates the application into distinct layers.
- Purpose: separation of concerns, easier maintenance, scalability, testing, and readability.
- Typical flow:
    HTTP Request → Routes → Controller → Service → Repository → Database
    - Routes: maps HTTP endpoints to controller functions.
    - Controller: handles HTTP requests/responses, validation, and formatting. No business logic.
    - Service: contains business logic, calls repository for data.
    - Repository: handles data persistence (CRUD operations).
    - Model: represents database schema (Mongoose/Sequelize/etc).

2. Best Practices for Code Structure
- Folder Architecture Example:
    src/
      controllers/      # HTTP request handlers
        consumer.controller.js
      services/         # Business logic
        consumer.service.js
      repositories/     # Database queries
        consumer.repository.js
      models/           # DB schemas
        consumer.model.js
      routes/           # Maps URLs to controllers
        consumer.routes.js
      utils/            # Helper functions (hashPassword, logger, etc.)
      middlewares/      # Custom Express middleware
      app.js            # Express app initialization
      server.js         # Server entry point

- Folder Purposes:
    controllers/: thin layer, call services, handle validation and responses
    services/: business logic, call repository
    repositories/: DB queries, encapsulate ORM/ODM
    models/: DB schema definitions
    routes/: define REST endpoints, no business logic
    utils/: helper functions
    middlewares/: auth, error handling, logging

3. Naming Conventions
- Controller: singular resource + .controller.js → consumer.controller.js
- Service: resource + .service.js → consumer.service.js
- Repository: resource + .repository.js → consumer.repository.js
- Model: resource + .model.js → consumer.model.js
- Routes: resource + .routes.js → consumer.routes.js
- Controller functions: getAll, create, getById, update, delete
- Service functions: getAllConsumers, createConsumer, etc.
- Repository functions: findAllConsumers, findConsumerById, etc.

4. Routes Folder Example
import { Router } from "express";
import { ConsumerController } from "../controllers/consumer.controller.js";

const router = Router();

router.get("/", ConsumerController.getAll);
router.post("/", ConsumerController.create);
router.get("/:id", ConsumerController.getById);
router.put("/:id", ConsumerController.update);
router.delete("/:id", ConsumerController.delete);

export default router;

Notes:
- Keep routes purely for mapping endpoints to controllers.
- Avoid putting business logic in routes.
- Import routes in app.js/server.js with:
    app.use("/api/consumers", consumerRoutes);

5. Named Exports vs Object of Functions

A. Named Exports (old/simple)
export const getAllConsumers = async (req, res) => { ... }
export const createConsumer = async (req, res) => { ... }

- Pros: simple, easy for small projects, can import individual functions
- Cons: no logical grouping, harder to scale, hard to wrap in middleware

B. Object of Functions (recommended)
export const ConsumerController = {
    async getAll(req, res) { ... },
    async create(req, res) { ... },
    async getById(req, res) { ... },
    async update(req, res) { ... },
    async delete(req, res) { ... },
};

- Pros: logical grouping, easier middleware wrapping, scales well, works with service/repository separation
- Usage in routes:
    router.get("/", ConsumerController.getAll);
    router.post("/", ConsumerController.create);

6. Summary / Recommendations
- Use object-of-functions for controllers in multi-layer architecture.
- Keep controllers thin; delegate business logic to services.
- Services call repositories for database access.
- Repositories handle database interactions only.
- Routes only map endpoints to controllers.
- Follow consistent naming conventions.
- This structure ensures maintainability, scalability, and readability in medium to large projects.
