
Entity Relationships:::::::::::::
Processor : 
  - Can create, update, and manage consumers, connections, and billing.
  - Can view and respond to issue reports.
  - Has a role (staff, manager).

Consumer : 
  - Can view their own profile, connections, bills, and issue reports.
  - Can create new issue reports (e.g., malfunctioning meter, leaking pipe)
  - Cannot modify billing or connection data.
  Relationships:
    - Consumer 1 - n connections
    - 1 Consumer - n issueReports

Connection:
  - Represents a water meter connection linked to a consumer
  - Each connection belongs to one consumer.
  - Each connection can have multiple billing records (monthly, quarterly, etc.)
  - Can be linked  to IssureReports if the issue is about a specific connection.
  Relationship: 
    - Connection n - 1 Consumer
    - Connection 1 - n billing

Billing:
  - Represents a single billing record for a connection (e,g. per month).
  - Belongs to exactly one connection.
  - Contains usage, rates total, payment status, etc.
  Relationships:
    - Billing n - 1 Connection

IssueReport: 
  - Create be a consumer.
  - Can optionally link to a connection (if the issue relates to it)
  - Managed by processor users who can update the status:
  - Pending | taking action | resolved

ENTITY RELATIONSHIP DIAGRAM :::::::::::::::::
Processor (role=staff|manager)
     │
     │ manages
     ▼
Consumer (1) ────< (n) Connection (1) ────< (n) Billing
     │
     │ reports
     ▼
IssueReport (status=pending|taking_action|resolved)
     │
     └── optional → Connection


- processor => manages => Consumer
- Consumer(1) => (many) connections
- Connection (1) => (many) Billings

ARCHITECTURE:
- this is a modern, scalable architecture, just like professional SaaS and municipal systems use today.
- we'll use MVC + Services + repository pattern, with a clean separation of concerns, modern ES Modules, and async/await across the stack.

PLANNED ARCHITECTURE:
water-billing-backend/
├── src/
│   ├── app.js
│   ├── server.js
│   ├── config/
│   │   └── db.js
│   ├── modules/
│   │   ├── auth/
│   │   │   ├── auth.controller.js
│   │   │   ├── auth.routes.js
│   │   │   ├── auth.service.js
│   │   │   ├── auth.repository.js
│   │   │   └── auth.validation.js
│   │   ├── users/        # Consumers + Processors
│   │   │   ├── user.model.js
│   │   │   ├── user.controller.js
│   │   │   ├── user.routes.js
│   │   │   ├── user.service.js
│   │   │   └── user.repository.js
│   │   ├── connections/
│   │   │   ├── connection.model.js
│   │   │   ├── connection.controller.js
│   │   │   ├── connection.routes.js
│   │   │   ├── connection.service.js
│   │   │   └── connection.repository.js
│   │   ├── billing/
│   │   │   ├── billing.model.js
│   │   │   ├── billing.controller.js
│   │   │   ├── billing.routes.js
│   │   │   ├── billing.service.js
│   │   │   └── billing.repository.js
│   │   └── reports/
│   │       ├── report.model.js
│   │       ├── report.controller.js
│   │       ├── report.routes.js
│   │       ├── report.service.js
│   │       └── report.repository.js
│   ├── middleware/
│   │   ├── auth.middleware.js
│   │   ├── role.middleware.js        # restrict access by role
│   │   ├── error.middleware.js
│   │   └── validate.middleware.js
│   ├── utils/
│   │   ├── ApiResponse.js
│   │   ├── generateToken.js
│   │   └── roles.js                  # define USER_ROLES constants
│   ├── core/
│   │   ├── logger.js
│   │   └── AppError.js
├── .env
├── package.json
└── README.md

KEY CONCEPTS::::::::::: 
Controller - Handles HTTP request/responses. Calls Service layer
Service - Contains business logic (calculations, validation)
Repository - Handles Database operations using Mongoose
Model - Define data schema
middleware - Reusable logic (auth, validation, error handling).
Utils - Small helpers (JWT, formatters, response.)

example code for Access control logic.
Use a Role middleware (role.middleware.js) to protect routes:

export const authorizeRoles = (...roles) => {
  return (req, res, next) => {
    if (!roles.includes(req.user.role)) {
      return res.status(403).json({ message: "Access Denied" });
    }
    next();
  };
};

Example usage:
// Only processors can create billing
router.post(
  "/",
  authMiddleware,
  authorizeRoles("processor", "manager"),
  billingController.createBilling
);

// Consumers can view their own billing
router.get(
  "/my-bills",
  authMiddleware,
  authorizeRoles("consumer"),
  billingController.getMyBills
);

Recommended Tech stack
Layer                    Technology
Runtime                   Node.js
Framework                 Express.js
Database                  MongoDB + Mongoose
Auth                      Jsession + cookie =>
validation                express-validator
Password hashing          bcrypt
Logging                   x => Winston or pino
Env Mgmt                  dotenv
Error handling            Centralized custom AppError
Dev Tools                 Nodemon, ESLint, Prettier
Testing                   Jest/Supertest





:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
ARCHITECTURE IMPLEMENTATION:::::::::::::::::::::::::::::::::::
Architecture V1: "flat MVC style" : MONOLITHIC
WATER_BILLING_SYSTEM/
│
├── coverage/
├── node_modules/
│
├── src/
│   ├── config/
│   │   └── settings.js
│   │
│   ├── controllers/
│   │   └── consumer.controller.js
│   │
│   ├── e2e/
│   │   └── index.test.js
│   │
│   ├── middlewares/
│   │   ├── authentication/
│   │   │   ├── requireAuth.js
│   │   │   └── requireAuthAndManager.js
│   │   │
│   │   ├── validationSchemas/
│   │   │   ├── addBillValidation.js
│   │   │   ├── addConnectionValidation.js
│   │   │   ├── addConsumerValidation.js
│   │   │   ├── editBillValidation.js
│   │   │   ├── editConnectionValidation.js
│   │   │   └── registerProcessorValidation.js
│   │   │
│   │   ├── authmiddleware.js
│   │   └── validateObjectId.js
│   │
│   ├── mongoose/
│   │   └── schemas/
│   │       ├── bill.js
│   │       ├── connection.js
│   │       ├── consumer.js
│   │       └── processor.js
│   │
│   ├── routes/
│   │   ├── auth.js
│   │   ├── bills.js
│   │   ├── connections.js
│   │   ├── consumers.js
│   │   ├── index.js
│   │   ├── issueReports.js
│   │   └── processors.js
│   │
│   ├── strategies/
│   │   └── local-strategy.js
│   │
│   ├── tests/
│   │   └── consumer.test.js
│   │
│   ├── utils/
│   │   ├── constants.js
│   │   └── helpers.js
│   │
│   ├── app.js
│   └── createApp.js
│
├── .babelrc
├── .env
├── buildprogress.txt
├── jest.config.mjs
├── jsconfig.json
├── package-lock.json
├── package.json


Architecture V2: Multilayer architecture / layered architecture ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

Multi-Layer Architecture in Express.js
1. What is Multi-Layer Architecture?
- Software design pattern that separates the application into distinct layers.
- Purpose: separation of concerns, easier maintenance, scalability, testing, and readability.
- Typical flow:
    HTTP Request → Routes → Controller → Service → Repository → Database
    - Routes: maps HTTP endpoints to controller functions.
    - Controller: handles HTTP requests/responses, validation, and formatting. No business logic.
    - Service: contains business logic, calls repository for data.
    - Repository: handles data persistence (CRUD operations).
    - Model: represents database schema (Mongoose/Sequelize/etc).

2. Best Practices for Code Structure
- Folder Architecture Example:
    src/
      controllers/      # HTTP request handlers
        consumer.controller.js
      services/         # Business logic
        consumer.service.js
      repositories/     # Database queries
        consumer.repository.js
      models/           # DB schemas
        consumer.model.js
      routes/           # Maps URLs to controllers
        consumer.routes.js
      utils/            # Helper functions (hashPassword, logger, etc.)
      middlewares/      # Custom Express middleware
      app.js            # Express app initialization
      server.js         # Server entry point

- Folder Purposes:
    controllers/: thin layer, call services, handle validation and responses
    services/: business logic, call repository
    repositories/: DB queries, encapsulate ORM/ODM
    models/: DB schema definitions
    routes/: define REST endpoints, no business logic
    utils/: helper functions
    middlewares/: auth, error handling, logging

3. Naming Conventions
- Controller: singular resource + .controller.js → consumer.controller.js
- Service: resource + .service.js → consumer.service.js
- Repository: resource + .repository.js → consumer.repository.js
- Model: resource + .model.js → consumer.model.js
- Routes: resource + .routes.js → consumer.routes.js
- Controller functions: getAll, create, getById, update, delete
- Service functions: getAllConsumers, createConsumer, etc.
- Repository functions: findAllConsumers, findConsumerById, etc.

4. Routes Folder Example
import { Router } from "express";
import { ConsumerController } from "../controllers/consumer.controller.js";

const router = Router();

router.get("/", ConsumerController.getAll);
router.post("/", ConsumerController.create);
router.get("/:id", ConsumerController.getById);
router.put("/:id", ConsumerController.update);
router.delete("/:id", ConsumerController.delete);

export default router;

Notes:
- Keep routes purely for mapping endpoints to controllers.
- Avoid putting business logic in routes.
- Import routes in app.js/server.js with:
    app.use("/api/consumers", consumerRoutes);

5. Named Exports vs Object of Functions

A. Named Exports (old/simple)
export const getAllConsumers = async (req, res) => { ... }
export const createConsumer = async (req, res) => { ... }

- Pros: simple, easy for small projects, can import individual functions
- Cons: no logical grouping, harder to scale, hard to wrap in middleware

B. Object of Functions (recommended)
export const ConsumerController = {
    async getAll(req, res) { ... },
    async create(req, res) { ... },
    async getById(req, res) { ... },
    async update(req, res) { ... },
    async delete(req, res) { ... },
};

- Pros: logical grouping, easier middleware wrapping, scales well, works with service/repository separation
- Usage in routes:
    router.get("/", ConsumerController.getAll);
    router.post("/", ConsumerController.create);

6. Summary / Recommendations
- Use object-of-functions for controllers in multi-layer architecture.
- Keep controllers thin; delegate business logic to services.
- Services call repositories for database access.
- Repositories handle database interactions only.
- Routes only map endpoints to controllers.
- Follow consistent naming conventions.
- This structure ensures maintainability, scalability, and readability in medium to large projects.

Folder structure as of 11-13-25 :::::::::::::::::::::::
WATER_BILLING_SYSTEM/
├── coverage/
├── node_modules/
├── config/
│   └── settings.js
├── controllers/
│   ├── auth.controller.js
│   ├── bill.controller.js
│   ├── connection.controller.js
│   ├── consumer.controller.js
│   └── processor.controller.js
├── middlewares/
│   ├── authentication/
│   │   ├── requireAuth.js
│   │   └── requireAuthAndManager.js
│   ├── validationSchemas/
│   │   ├── addBillValidation.js
│   │   ├── addConnectionValidation.js
│   │   ├── addConsumerValidation.js
│   │   ├── editBillValidation.js
│   │   ├── editConnectionValidation.js
│   │   ├── editProcessorValidation.js
│   │   ├── registerManagerValidation.js
│   │   ├── registerProcessorValidation.js
│   │   └── validateObjectId.js
│   ├── authmiddleware.js
│   └── validateObjectId.js
├── models/
│   ├── bill.model.js
│   ├── connection.model.js
│   ├── consumer.model.js
│   └── processor.model.js
├── repositories/
│   ├── bill.repository.js
│   ├── connection.repository.js
│   ├── consumer.repository.js
│   └── processor.repository.js
├── routes/
│   ├── auth.routes.js
│   ├── bills.routes.js
│   ├── connections.routes.js
│   ├── consumers.routes.js
│   ├── processors.routes.js
│   └── index.js
├── services/
│   ├── bill.service.js
│   ├── connection.service.js
│   ├── consumer.service.js
│   └── processor.service.js
├── strategies/
│   └── local-strategy.js
├── tests/
│   ├── e2e/
│   │   └── index.test.js
│   └── unit/
│       ├── controllers/
│       │   └── consumer.controller.test.js
│       └── services/
├── utils/
│   ├── constants.js
│   ├── helpers.js
│   └── validateObjectId.js
├── .env
├── .gitignore
├── buildprogress.txt
├── jest_config.mjs
├── jsconfig.json
├── package-lock.json
├── package.json
├── README.md
├── app.js
├── createApp.js
└── .babelrc



Architecture V3: Modularize Clean Architecture ()
this version modernizes your (Arch V2) current multi-layer setup into feature-based modular architecture, which is now the most used and recommended best practice for Express.js + Mongoose apps (especially SaaS-style projects).
1. Concept Overview
- The Modularized Clean Architecture combines: 
  - Feature-based modularization (group by feature, not by layer)
  - Clean separation of concerns (controller, service, repository)
  - Scalable organization for medium-to-large apps.
  ✅ Goal: Each module (Auth, Billing, Consumer, etc.) is self-contained, meaning it includes its own model, controller, service, repository, and routes — making it portable and independent.
  ✅ Why: This improves scalability, testing, reusability, and code navigation as the project grows. It’s the structure used by modern Node.js SaaS backends and enterprise Express apps.

2. Request Flow (Clean Flow)
HTTP Request 
 → Route 
 → Controller 
 → Service 
 → Repository 
 → Model (Mongoose)

Route: maps the endpoint to a controller.
Controller: handles HTTP layer (request, response, status codes, validation errors).
Service: holds business logic (e.g., calculations, validation, permissions).
Repository: interacts with the database (Mongoose queries only).
Model: defines the database schema.
Middleware: shared logic (auth, role guard, error handler).
Utils/Core: reusable helpers (logger, token generation, response formatters).

3. How Modules works
Each folder inside /modules is an independent feature.
Inside src/modules/billing for example

billing/
├── billing.model.js        # Mongoose schema
├── billing.repository.js   # CRUD database operations
├── billing.service.js      # Business logic
├── billing.controller.js   # Handles requests/responses
├── billing.routes.js       # Express routes
└── billing.validation.js   # express-validator rules (optional)

You imoprt these routes into app.js:
import billingRoutes from "./modules/billing/billing.routes.js";
app.use("/api/billing", billingRoutes);

4. Module Example Flow
billing.routes.js:
import { Router } from "express";
import { BillingController } from "./billing.controller.js";
import { authMiddleware } from "../../middleware/auth.middleware.js";
import { authorizeRoles } from "../../middleware/role.middleware.js";

const router = Router();

router.post(
  "/",
  authMiddleware,
  authorizeRoles("processor", "manager"),
  BillingController.createBilling
);

router.get(
  "/my-bills",
  authMiddleware,
  authorizeRoles("consumer"),
  BillingController.getMyBills
);

export default router;


5. Middleware Layer (Shared Across Modules)
auth.middleware.js → Verify JWT/session.
role.middleware.js → Restrict access based on role.
error.middleware.js → Centralized error handler.
validate.middleware.js → Use express-validator.

6. Core & Utils
| File               | Responsibility                              |
| ------------------ | ------------------------------------------- |
| `AppError.js`      | Central custom error class with status code |
| `logger.js`        | Use Winston or Pino for structured logs     |
| `ApiResponse.js`   | Unified success/error response format       |
| `generateToken.js` | JWT generation                              |
| `roles.js`         | USER_ROLES constants                        |

7. Benefits of Modularized Clean Architecture
✅ Each module is independent — you can move, test, or reuse it easily.
✅ Improves maintainability — less coupling between features.
✅ Ideal for scaling (e.g., add new feature module /notifications without touching others).
✅ Easier to apply domain-driven design (DDD) principles later.
✅ Works perfectly with TypeScript migration.

8. Future-Proof Additions (Operational Enhancements)
  - Add /core/database.js for unified DB initialization.
  - Add /config/env.js for typed environment configuration.
  - dd /tests/modules/ matching structure for per-module tests.
  - Add /shared/ for common constants/enums used across modules.